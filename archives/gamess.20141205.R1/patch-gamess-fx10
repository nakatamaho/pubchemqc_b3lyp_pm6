--- gamess/compall	2013-05-04 05:19:16.000000000 +0900
+++ gamess/compall	2014-04-17 11:03:01.000000000 +0900
@@ -1,4 +1,4 @@
-#!/bin/csh
+#!/bin/tcsh -f
 #
 #  last update = 17 May 2013
 #
@@ -59,6 +59,8 @@
 if  ($TARGET == linux32)                          set CCOMP='gcc'
 if  ($TARGET == linux64)                          set CCOMP='gcc'
 if  ($TARGET == necsx)                            set CCOMP='c++'
+if  ($TARGET == xtcos)                            set CCOMP='mpifcc'
+if (($TARGET == xtcos) && (`uname` == Linux))     set CCOMP='mpifccpx'
 #
 unset extraflags
 #
@@ -70,6 +72,7 @@
 if ($TARGET == cray-xt)      set extraflags='-DLINUX64'
 if ($TARGET == fuji-pp32)    set extraflags='-DSUN32'
 if ($TARGET == fuji-pp64)    set extraflags='-DSUN64 -KV9'
+if ($TARGET == xtcos)        set extraflags='-O0 -SSL2MPI -SSL2BLAMP -DLINUX64 -CcdII8'
 if ($TARGET == hpux32)       goto skip-zunix
 if ($TARGET == hpux64)       goto skip-zunix
 if ($TARGET == ibm32)        set extraflags='-DIBM32'
@@ -235,6 +238,7 @@
 if ($TARGET == mac64)      ./comp blaswrap
 if ($TARGET == sgi64)      ./comp blaswrap
 if ($TARGET == sun64)      ./comp blaswrap
+if ($TARGET == xtcos)      ./comp blaswrap
 #
 #  If this is a vector machine, we must compile the vectorized routines
 #


--- gamess/config	2013-05-18 01:15:04.000000000 +0900
+++ gamess/config	2014-04-17 11:03:01.000000000 +0900
@@ -175,6 +175,17 @@
 #    Depending on the situation, we may set a few other values as well.
 #
 switch ($GMS_TARGET)
+#
+# GAMESS on FX10 
+#
+case xtcos:
+
+echo "   Compiling on 'xtcos' on FX10 of Fujitsu."
+echo  "The FORTRUN compiler is named 'mpifrtpx' for cross compiling."
+set GMS_FORTRAN="mpifrt"
+if (`uname` == Linux) set GMS_FORTRAN="mpifrtpx"
+set GMS_MATHLIB='SSL2MPI'
+breaksw
 
 case axp64:
 
@@ -417,6 +428,12 @@
 echo " "
 
 switch ($GMS_FORTRAN)
+
+   case mpifrtpx:
+      set GMS_FRTPX_OPT="-Kfast -SSL2MPI -SSL2BLAMP"
+      set GMS_TARGET=xtcos
+      breaksw
+
    case g77:
       #       we expect this choice only on rather old 32 bit kernels
       set GMS_TARGET=linux32
@@ -1328,6 +1345,13 @@
    endif
 #
    switch ($GMS_FORTRAN)
+      case mpifrtpx:
+　　　case mpifrt:
+         set echo
+           gfortran -o $GMS_BUILD_DIR/tools/actvte.x actvte.f
+         unset echo
+         breaksw  
+
       case ifort:
          if (($GMS_TARGET == win32) || ($GMS_TARGET == win64) || ($GMS_TARGET == winazure)) then
            if (! $?VCINSTALLDIR) then
@@ -1418,6 +1442,11 @@
 if ($GMS_TARGET == ibm-sp)   set GMS_DDI_COMM='lapi'
 if ($GMS_TARGET == sgi64)    set GMS_DDI_COMM='shmem'
 #
+if ($GMS_TARGET == xtcos)  then
+                             set GMS_DDI_COMM='mpi'
+                             set GMS_MPI_LIB='Fujitsu-MPI'
+endif
+
 if ($GMS_TARGET == linux64) then
    echo " "
    echo -n "please hit <return> to set up your network for Linux clusters."


--- gamess/ddi/src/ddi_fortran.c	2013-04-19 00:30:45.000000000 +0900
+++ gamess/ddi/src/ddi_fortran.c	2014-04-18 10:52:17.000000000 +0900
@@ -363,11 +363,13 @@
       fprintf(stdout,"%s: DDI_Scatter_Acc for WINTEL not implemented.\n",DDI_Id());
       Fatal_error(911);
     # endif
+      /*
       Scattered.oper   = DDI_ACC;
       Scattered.handle = (int) *handle;
       Scattered.nelem = (int) *nelem;
       Scattered.alpha = alpha;
       DDI_Scatter_AccS(Scattered.handle,&Scattered,alpha,ibuff,buff);
+      */
    }
 
 
--- gamess/ddi/src/ddi_server.c	2013-04-19 00:30:45.000000000 +0900
+++ gamess/ddi/src/ddi_server.c	2014-04-18 10:49:56.000000000 +0900
@@ -208,7 +208,7 @@
          # if defined WINTEL
           fprintf(stdout,"%s: DDI_Scatter_Acc for WINTEL not implemented.\n",DDI_Id());
           Fatal_error(911);
-           case DDI_ACC_OP:
+           case DDI_SCATTER_ACC:
          # else
            case DDI_SCATTER_ACC:
          # endif

--- gamess.org/lked	2013-05-18 01:15:06.000000000 +0900
+++ gamess/lked	2014-04-18 10:55:14.000000000 +0900
@@ -105,6 +105,19 @@
 # for all systems use GAMESS LAPACK (by default)
    set LAPACK='dgeev.o dgesvd.o zheev.o'
 
+#   Fujitsu FX10
+#
+if ($TARGET == xtcos) then
+   set LDR='mpifrt'
+   if (`uname` == Linux) set LDR='mpifrtpx'
+   set LDOPTS='-O0 -SSL2BLAMP -SSL2MPI -CcdII8'
+   set LIBRARIES=' '
+   set BLAS='blaswrap.o'
+   set LAPACK=' '
+   set VECTOR=' '
+   set QUICHE='zunix.o'
+endif
+
 #   Digital/Compaq/HP 64 bit "alpha workstation"
 #   Use the Digital/Compaq eXtended Math Library for BLAS if installed.
 #
@@ -1142,6 +1157,11 @@
    case winazure:
       set MSG_LIBRARIES=serial.o
       breaksw
+   case xtcos:
+       set MPILIBS="-SSL2MPI"
+       set GMS_MPI_PATH=""
+       set MSG_LIBRARIES="$GMS_BUILD_DIR/ddi/libddi.a $MPILIBS -SSL2BLAMP"
+       breaksw
 #               to get here must be a target typo.
    default:
       echo The lked script does not select a correct TARGET machine type.

--- gamess/ddi/compddi	2013-05-04 05:14:15.000000000 +0900
+++ gamess/ddi/compddi	2014-05-07 10:21:31.000000000 +0900
@@ -1,4 +1,4 @@
-#!/bin/csh
+#!/bin/csh -x
 #
 #  15 Feb 11 - script to compile the Distributed Data Interface (DDI)
 #
@@ -120,6 +120,7 @@
 if ($COMM == armci)      set SYSV=false
 if ($TARGET == win32)    set SYSV=false
 if ($TARGET == win64)    set SYSV=false
+if ($TARGET == xtcos)    set SYSV=false
 
 #  5.    If you are unable to compile the new DDI source code, in case
 #        your operating system is very old (e.g. > 10 years) you might
@@ -240,6 +241,7 @@
 #            big machines will find their mpi.f, don't check it.
      case IBM-BlueGene-MPI:
      case Cray-XT-MPI:
+     case Fujitsu-MPI:
         goto skip_mpi_setup
         breaksw
      default:
@@ -801,6 +803,28 @@
 
   endif
 
+# ------------ #
+# Fujitsu FX10
+# ------------ #
+if ($TARGET == xtcos)   set GMS_MPI_LIB=Fujitsu-MPI
+
+  if($TARGET == xtcos) then
+     set UNAME = `uname`
+                         set CC = 'mpifcc'
+     if($UNAME == Linux) set CC = 'mpifccpx'
+                         set NumUS=1
+
+     set CFLAGS = "-O0 -SSL2MPI -SSL2BLAMP -DWINTEL -DDDI_BUFFER_SIZE=786432"
+     set CLIBS = ''
+     set F77_OPTS = "-DINT_SIZE=long -D_UNDERSCORES=$NumUS"
+     set AR_FLAGS     = 'cr'
+     set RANLIB_FLAGS = ' '
+
+     set FORTRAN    = 'mpifrt'
+     if($UNAME == Linux) set FORTRAN = 'mpifrtpx'
+     set FORT_FLAGS = '-O0 -SSL2MPI -SSL2BLAMP -CcdII8'
+     set FORT_LIBS  = ''
+   endif
 
 # ---------- #
 # SGI 32-bit #
@@ -820,6 +844,28 @@
 
   endif
 
+# ------------ #
+# Fujitsu FX10
+# ------------ #
+if ($TARGET == xtcos)   set GMS_MPI_LIB=Fujitsu-MPI
+
+  if($TARGET == xtcos) then
+     set UNAME = `uname`
+                         set CC = 'mpifcc'
+     if($UNAME == Linux) set CC = 'mpifccpx'
+                         set NumUS=1
+
+     set CFLAGS = "-O0 -SSL2MPI -SSL2BLAMP -DWINTEL -DDDI_BUFFER_SIZE=786432"
+     set CLIBS = ''
+     set F77_OPTS = "-DINT_SIZE=long -D_UNDERSCORES=$NumUS"
+     set AR_FLAGS     = 'cr'
+     set RANLIB_FLAGS = ' '
+
+     set FORTRAN    = 'mpifrt'
+     if($UNAME == Linux) set FORTRAN = 'mpifrtpx'
+     set FORT_FLAGS = '-O0 -SSL2MPI -SSL2BLAMP -CcdII8'
+     set FORT_LIBS  = ''
+   endif
 
 # ---------- #
 # SGI 64-bit #
@@ -1068,6 +1114,7 @@
            endif
            breaksw
         case Cray-XT-MPI:
+        case Fujitsu-MPI:
         case IBM-BlueGene-MPI:
            breaksw
         default:
--- gamess.org/comp	2013-05-04 05:18:53.000000000 +0900
+++ gamess/comp	2014-05-07 11:16:40.000000000 +0900
@@ -117,6 +117,7 @@
 if ($TARGET == win32)      set OK=true
 if ($TARGET == win64)      set OK=true
 if ($TARGET == winazure)   set OK=true
+if ($TARGET == xtcos)      set OK=true
 if ($OK == false) then
    echo The comp script does not select a correct TARGET machine type.
    echo What you typed when editing this script was $TARGET
@@ -151,6 +152,7 @@
 endif
 if  ($TARGET == fuji-pp32)    set BLAS3=true
 if  ($TARGET == fuji-pp64)    set BLAS3=true
+if  ($TARGET == xtcos)        set BLAS3=true
 if  ($TARGET == hpux32)       set BLAS3=true
 if  ($TARGET == hpux64)       set BLAS3=true
 if  ($TARGET == ibm32)        set BLAS3=true
@@ -412,6 +414,7 @@
 if ($TARGET == mac64)     goto act
 if ($TARGET == sgi64)     goto act
 if ($TARGET == sun64)     goto act
+if ($TARGET == xtcos)     goto act
 #
 #   Any module with machine dependent code must be activated...
 #
@@ -507,6 +510,12 @@
    if ($MODULE == iolib)  setenv MACHIN '*UNX'
    if ($MODULE == unport) setenv MACHIN '*DEC'
 endif
+if ($TARGET == xtcos) then
+                          setenv MACHIN '*I64'
+   if ($MODULE == ddi)    setenv MACHIN '*MPI'
+   if ($MODULE == iolib)  setenv MACHIN '*UNX'
+   if ($MODULE == unport) setenv MACHIN '*L64'
+endif
 #       the old Cray vector systems would use TCP/IP sockets in DDI
 if ($TARGET == cray-pvp) then
                           setenv MACHIN '*I64'
@@ -725,6 +734,7 @@
 if (($MODULE == unport) && \
     (($TARGET == fuji-pp64) || \
      ($TARGET == hpux64)    || \
+     ($TARGET == xtcos)    || \
      ($TARGET == ibm64)     || \
      ($TARGET == ibm64-sp)  || \
      ($TARGET == sgi64)     || \
@@ -753,6 +763,7 @@
 #
 set mathhack=false
 if ($TARGET == fuji-pp64) set mathhack=true
+if ($TARGET == xtcos) set mathhack=true
 if ($TARGET == ibm64)     set mathhack=true
 if ($TARGET == ibm64-sp)  set mathhack=true
 if ($TARGET == mac64) then
@@ -888,6 +899,7 @@
      case myrinet:
      case openmpi:
      case mpt:
+     case Fujitsu-MPI:
         set FGEhack=false
         breaksw
      case mpich2:
@@ -2381,6 +2393,17 @@
    endsw
 #                     ... end of Windows on 32 bit processors.
 endif
+if ($TARGET == xtcos) then
+                         set FORT='mpifrt'
+   if (`uname` == Linux) set FORT='mpifrtpx'
+#   set OPT = '-Kfast -SSL2 -SSL2BLAMP'
+   set OPT = '-O2 -SSL2MPI -SSL2BLAMP -CcdII8'
+   if ($MODULE == zheev) set OPT='-O0 -CcdII8'
+   if ($MODULE == cimi) set OPT='-O0 -SSL2MPI -SSL2BLAMP -CcdII8'
+   set echo
+   $FORT -c $OPT $MODULE.f
+   unset echo
+endif
 #
 #   ------ Windows on 64 bit chips ------
 #
--- gamess.org/rungms	2013-05-18 01:15:11.000000000 +0900
+++ rungms	2014-05-07 14:37:03.000000000 +0900
@@ -59,10 +59,12 @@
 #       both Sun Grid Engine (SGE), and Portable Batch System (PBS).
 #       See also a very old LoadLeveler "ll-gms" for some IBM systems.
 #
-set TARGET=sockets
-set SCR=/scr/$USER
-set USERSCR=~$USER/scr
-set GMSPATH=/u1/mike/gamess
+setenv LANG C
+set TARGET=mpi
+set SCR=.
+set USERSCR=.
+set GMSPATH=%%QCTOPDIR%%/build/gamess
+set NNODES=1
 #
 set JOB=$1      # name of the input file xxx.inp, give only the xxx part
 set VERNO=$2    # revision number of the executable created by 'lked' step
@@ -75,7 +77,7 @@
 #  ---- the top third of the script is input and other file assignments ----
 #
 echo "----- GAMESS execution script 'rungms' -----"
-set master=`hostname`
+set master=localhost
 echo This job is running on host $master
 echo under operating system `uname` at `date`
 #
@@ -97,11 +99,6 @@
    uniq $PBS_NODEFILE
 endif
 #
-echo "Available scratch disk space (Kbyte units) at beginning of the job is"
-df -k $SCR
-echo "GAMESS temporary binary files will be written to $SCR"
-echo "GAMESS supplementary output files will be written to $USERSCR"
-
 #        this added as experiment, February 2007
 #        its intent is to detect large arrays allocated off the stack
 limit stacksize 8192
@@ -267,7 +264,18 @@
 #       1. Sequential execution is sure to be on this very same host
    if ($NCPUS == 1) then
       set NNODES=1
-      set HOSTLIST=(`hostname`)
+      set HOSTLIST=localhost
+   endif
+   if ($NCPUS >= 1) then
+      set NNODES=$NCPUS
+      set HOST=localhost
+      set HOSTLIST=$HOST
+      @ CPU=1
+      while ($CPU < $NNODES)
+         set HOSTLIST=($HOSTLIST $HOST)
+         @ CPU++
+      end
+      unset $CPU
    endif
 #
 #       2. This is an example of how to run on a multi-core SMP enclosure,
@@ -308,8 +316,7 @@
             set HOSTLIST=(`hostname`:cpus=$NCPUS)
             breaksw
          default:
-            echo I do not know how to run this node in parallel.
-            exit 20
+            breaksw
       endsw
    endif
 #
@@ -511,6 +518,7 @@
 #         sliced-and-diced into the format required by your MPI kickoff.
 #
 if ($TARGET == mpi) then
+/usr/bin/time -a -o gms.out mpiexec -std gms.out -n $NCPUS $GMSPATH/gamess.$VERNO.x $JOB < /dev/null
    #
    #      Besides the usual three arguments to 'rungms' (see top),
    #      we'll pass in a "processers per node" value, that is,

